{
  "hash": "d966804a09d75dec180dbff2a023d886",
  "result": {
    "engine": "jupyter",
    "markdown": "# Risk-Free Rate Construction in Vietnam\n\n::: callout-note\nIn this chapter, we address a simple but consequential problem: how to construct a risk-free rate series for empirical finance in Vietnam. We evaluate available proxies, such as government bond yields, interbank overnight rates, and State Bank of Vietnam (SBV) policy rates, develop interpolation and frequency-alignment procedures, and quantify the sensitivity of key asset pricing outputs to the choice of risk-free proxy.\n:::\n\nThe risk-free rate is the most important single number in finance. It anchors excess returns, discount rates, factor premiums, the cost of equity, performance evaluation, and derivative pricing. Despite its foundational role, the risk-free rate is often treated as a given: a number downloaded from a database and plugged into formulas without further thought. In developed markets with deep, liquid government securities markets, this casual approach is usually harmless. In Vietnam, it is not.\n\nVietnam's fixed-income market is thin, fragmented, and characterized by irregular issuance of short-term government securities. There is no single, universally accepted risk-free rate analogous to the 1-month Treasury bill rate that anchors virtually all asset pricing research in mature markets. Instead, researchers face a choice among imperfect proxies, each with distinct advantages and limitations. This choice is not innocuous: different proxies can produce meaningfully different excess returns, factor premiums, and valuation estimates.\n\nThis chapter develops a systematic approach to risk-free rate construction. We begin with the theoretical requirements for a risk-free asset, then evaluate available Vietnamese proxies against these requirements. We construct monthly risk-free rate series under alternative specifications, demonstrate frequency alignment and interpolation techniques, and conduct sensitivity analysis to quantify how the choice of proxy affects downstream results.\n\n## The Role of the Risk-Free Rate in Finance\n\n### Excess Returns\n\nThe most fundamental use of the risk-free rate is in the computation of excess returns. The excess return on asset $i$ in period $t$ is:\n\n$$\nr_{i,t}^{e} = r_{i,t} - r_{f,t}\n$$ {#eq-excess-return}\n\nwhere $r_{i,t}$ is the raw return and $r_{f,t}$ is the risk-free rate over the same period, in the same currency, and under the same compounding convention. Excess returns isolate the compensation for bearing risk, removing the return that could be earned without risk exposure.\n\nMismeasurement of $r_{f,t}$ directly contaminates every excess return observation and, by extension, every quantity derived from excess returns. If $r_{f,t}$ is systematically biased upward, excess returns are systematically understated, factor premiums are compressed, and the cost of equity is overstated.\n\n### Factor Premiums\n\nIn the @Fama1993 three-factor model, the market risk premium is:\n\n$$\n\\text{MKTRF}_t = r_{m,t} - r_{f,t}\n$$ {#eq-mktrf}\n\nwhere $r_{m,t}$ is the value-weighted market return. The size (SMB) and value (HML) premiums are defined as returns on long-short portfolios and do not directly depend on $r_{f,t}$. However, the intercept (alpha) from a time-series regression of any portfolio's excess return on the factors does depend on $r_{f,t}$ through the dependent variable. A biased risk-free rate shifts all alphas uniformly.\n\n### Discount Rates and Valuation\n\nThe discounted cash flow model values a firm as:\n\n$$\nV_0 = \\sum_{t=1}^{\\infty} \\frac{E[CF_t]}{(1 + r_{WACC})^t}\n$$ {#eq-dcf}\n\nwhere the weighted average cost of capital (WACC) depends on the cost of equity, which in turn depends on the risk-free rate through the Capital Asset Pricing Model:\n\n$$\nr_{e} = r_f + \\beta_i (\\bar{r}_m - r_f)\n$$ {#eq-capm-cost}\n\nA 100 basis point error in $r_f$ flows through to the cost of equity and can change the present value of a long-duration cash flow stream by 10-20%, depending on the duration profile.\n\n### Performance Evaluation\n\nRisk-adjusted performance measures such as the Sharpe ratio:\n\n$$\n\\text{SR} = \\frac{\\bar{r}_p - \\bar{r}_f}{\\sigma(r_p - r_f)}\n$$ {#eq-sharpe}\n\nand Jensen's alpha:\n\n$$\n\\alpha = \\bar{r}_p - r_f - \\hat{\\beta}_p (\\bar{r}_m - r_f)\n$$ {#eq-jensen}\n\nboth depend directly on $r_f$. The Sharpe ratio is particularly sensitive because the denominator (excess return volatility) is also affected by the level and variability of $r_f$.\n\n## What Does \"Risk-Free\" Mean in Practice?\n\nA truly risk-free asset must satisfy four conditions simultaneously (@tbl-rf-requirements).\n\n| Condition | Definition | Practical Challenge |\n|--------------------|--------------------|--------------------------------|\n| No default risk | The issuer cannot fail to pay | Only sovereign debt in one's own currency qualifies |\n| Known cash flows | Payoff is certain ex ante | Rules out floating-rate instruments |\n| No reinvestment risk | Maturity matches the investment horizon | Requires zero-coupon securities of exact maturity |\n| High liquidity | Can be traded at a low cost | Thin government bond markets fail this test |\n\n: Requirements for a Risk-Free Asset {#tbl-rf-requirements}\n\nNo real-world asset perfectly satisfies all four conditions. Even in the deepest government bond markets, there is a liquidity premium in off-the-run securities and a convenience yield in on-the-run issues [@krishnamurthy2012aggregate]. The practical question is: which available instrument comes closest?\n\n### The Ideal Proxy\n\nThe ideal risk-free rate proxy for empirical asset pricing research has the following properties:\n\n1.  **Short maturity**: Minimizes reinvestment risk and term premium contamination. The conventional choice is 1-month maturity.\n2.  **Government-backed**: Eliminates credit risk (in domestic currency).\n3.  **Actively traded**: Ensures that the observed yield reflects current market conditions.\n4.  **Regular issuance**: Provides a continuous time series without gaps.\n5.  **Consistent methodology**: Yield computation is unambiguous and comparable over time.\n\n## Available Proxies in Vietnam\n\nVietnam's financial infrastructure provides several candidate instruments, none of which perfectly satisfies all criteria. We evaluate each in turn.\n\n### Government Bond Yields\n\nThe Vietnamese government issues bonds across a range of maturities through the State Treasury and the Vietnam Bond Market (VBM). Key characteristics:\n\n\nThe primary limitation of government bond yields as a risk-free proxy is the scarcity of short-maturity securities. One-year bonds are the shortest regularly issued benchmark, and their yield includes a term premium that is absent from a true risk-free rate. Treasury bills (maturity \\< 1 year) are issued irregularly and in small volumes, making them unsuitable as a continuous series.\n\n### Interbank Overnight Rate\n\nThe Vietnam interbank market sets overnight lending rates between commercial banks. The overnight rate is reported by the SBV.\n\n**Advantages**: Very short maturity (overnight), high frequency (daily), reflects actual borrowing costs in the financial system.\n\n**Limitations**: Reflects banking sector credit risk (interbank default risk, though small), can be volatile during liquidity crunches, and does not correspond to a tradeable zero-coupon instrument.\n\n### SBV Policy Rates\n\nThe State Bank of Vietnam sets several administered rates (@tbl-sbv-rates).\n\n| Rate | Role | Frequency of Change |\n|------------------|------------------|------------------------------------|\n| Refinancing rate | Rate at which SBV lends to banks | Infrequent (policy meetings) |\n| Discount rate | Rate for rediscounting eligible paper | Infrequent |\n| Overnight lending rate | Ceiling for interbank overnight | Infrequent |\n| Deposit rate cap | Maximum rate banks can pay on deposits | Infrequent |\n\n: SBV Policy Rates {#tbl-sbv-rates}\n\n**Advantages**: Stable (changes infrequently), reflects the monetary policy stance, available for the entire sample period.\n\n**Limitations**: Not a traded return (i.e., no investor can actually earn the policy rate). Represents an administrative target, not a market-clearing price. Responds to macroeconomic conditions with a lag.\n\n### Savings Deposit Rates\n\nCommercial banks offer term deposits at rates subject to SBV caps. Short-term (1-month or 3-month) deposit rates are sometimes used as informal risk-free proxies in practitioner contexts.\n\n**Advantages**: Represent an investable return for small investors, widely available.\n\n**Limitations**: Subject to bank credit risk, vary across banks, caps create a ceiling that may not reflect true equilibrium rates, not standardized for research use.\n\n### Summary Comparison\n\n\n## Constructing the Risk-Free Rate Series\n\nWe now construct alternative monthly risk-free rate series and examine their properties.\n\n### Loading and Cleaning Rate Data\n\n::: {#load-rf-data .cell execution_count=3}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n# Assume rf_data contains: date, rate_type, rate_annual (annualized, in %)\nrf_raw = pd.read_parquet(\"data/risk_free_rates.parquet\")\n\n# Preview available rate types\nprint(\"Available rate types:\")\nprint(rf_raw[\"rate_type\"].value_counts())\n```\n:::\n\n\n::: {#fig-rf-raw-series .cell execution_count=4}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8, 4.5))\n\ncolors = {\n    \"govt_bond_1y\": \"#2C73D2\",\n    \"interbank_overnight\": \"#FF6B6B\",\n    \"sbv_refinancing\": \"#5DCEAF\",\n    \"tbill_3m\": \"#FFB347\",\n    \"deposit_1m\": \"#B19CD9\"\n}\n\nfor rate_type, color in colors.items():\n    subset = rf_raw[rf_raw[\"rate_type\"] == rate_type].sort_values(\"date\")\n    if len(subset) > 0:\n        ax.plot(\n            subset[\"date\"], subset[\"rate_annual\"],\n            label=rate_type.replace(\"_\", \" \").title(),\n            color=color, linewidth=1.2, alpha=0.85\n        )\n\nax.set_ylabel(\"Annualized Rate (%)\")\nax.set_xlabel(\"\")\nax.legend(frameon=False, fontsize=9, loc=\"upper right\")\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n### Frequency Alignment\n\nAsset pricing tests require monthly risk-free rates. Raw data may arrive at daily, weekly, or irregular frequencies. We use the following conversion logic:\n\n**Daily to monthly**: Take the average of daily rates within each month, then convert from annualized to monthly.\n\n**Irregular to monthly**: For series with gaps (e.g., treasury bills), forward-fill the most recent observation, then average within each month.\n\n**Annualized to monthly**: Under simple compounding, $r_f^{monthly} = r_f^{annual} / 12$. Under continuous compounding, $r_f^{monthly} = r_f^{annual} / 12$ (since continuous rates are additive). We use simple compounding for consistency with the convention that stock returns are computed as arithmetic returns.\n\n::: {#construct-monthly-rf .cell execution_count=5}\n``` {.python .cell-code}\n# Construct monthly risk-free rates from each proxy\n\ndef construct_monthly_rf(rf_raw, rate_type, method=\"mean\"):\n    \"\"\"\n    Convert raw rate data to monthly frequency.\n\n    Parameters\n    ----------\n    rf_raw : pd.DataFrame\n        Raw rate data with columns: date, rate_type, rate_annual\n    rate_type : str\n        Which rate proxy to use\n    method : str\n        Aggregation method: 'mean', 'last', or 'first'\n\n    Returns\n    -------\n    pd.DataFrame\n        Monthly risk-free rate with columns: date, rf_monthly\n    \"\"\"\n    subset = (\n        rf_raw[rf_raw[\"rate_type\"] == rate_type]\n        .sort_values(\"date\")\n        .set_index(\"date\")\n    )\n\n    # Forward-fill gaps (for irregular series)\n    subset = subset.resample(\"D\").ffill()\n\n    # Aggregate to monthly\n    if method == \"mean\":\n        monthly = subset.resample(\"ME\")[\"rate_annual\"].mean()\n    elif method == \"last\":\n        monthly = subset.resample(\"ME\")[\"rate_annual\"].last()\n    else:\n        monthly = subset.resample(\"ME\")[\"rate_annual\"].first()\n\n    monthly = monthly.reset_index()\n    monthly.columns = [\"date\", \"rf_annual\"]\n\n    # Convert annualized rate (%) to monthly decimal\n    monthly[\"rf_monthly\"] = monthly[\"rf_annual\"] / 100 / 12\n\n    return monthly[[\"date\", \"rf_monthly\", \"rf_annual\"]]\n\n# Construct series for each proxy\nrf_proxies = {}\nfor proxy in [\"govt_bond_1y\", \"interbank_overnight\", \"sbv_refinancing\"]:\n    rf_proxies[proxy] = construct_monthly_rf(rf_raw, proxy)\n    rf_proxies[proxy][\"proxy\"] = proxy\n\nrf_all = pd.concat(rf_proxies.values(), ignore_index=True)\n```\n:::\n\n\n### Handling Missing Data and Structural Breaks\n\nVietnamese rate data may contain gaps due to market closures, reporting changes, or the introduction of new instruments. We handle these systematically:\n\n::: {#check-missing .cell execution_count=6}\n``` {.python .cell-code}\n# Check coverage for each proxy\ncoverage = (\n    rf_all\n    .groupby(\"proxy\")\n    .agg(\n        start_date=(\"date\", \"min\"),\n        end_date=(\"date\", \"max\"),\n        n_months=(\"rf_monthly\", \"count\"),\n        n_missing=(\"rf_monthly\", lambda x: x.isna().sum()),\n        avg_rate_pct=(\"rf_annual\", \"mean\")\n    )\n    .round(2)\n)\n\nprint(coverage)\n```\n:::\n\n\nFor periods where the primary proxy is unavailable, we construct a blended series using a priority hierarchy:\n\n::: {#construct-blended-rf .cell execution_count=7}\n``` {.python .cell-code}\ndef construct_blended_rf(rf_proxies, priority=None):\n    \"\"\"\n    Construct a blended monthly risk-free rate using proxy priority.\n\n    Priority order (default):\n    1. Treasury bills (shortest maturity, sovereign)\n    2. Interbank overnight (short maturity, high frequency)\n    3. 1-year government bond (sovereign, regular)\n    4. SBV refinancing rate (fallback)\n    \"\"\"\n    if priority is None:\n        priority = [\n            \"tbill_3m\",\n            \"interbank_overnight\",\n            \"govt_bond_1y\",\n            \"sbv_refinancing\"\n        ]\n\n    # Create full date range\n    all_dates = pd.date_range(\n        start=min(df[\"date\"].min() for df in rf_proxies.values()),\n        end=max(df[\"date\"].max() for df in rf_proxies.values()),\n        freq=\"ME\"\n    )\n\n    blended = pd.DataFrame({\"date\": all_dates})\n    blended[\"rf_monthly\"] = np.nan\n    blended[\"source\"] = \"\"\n\n    for proxy in priority:\n        if proxy in rf_proxies:\n            proxy_df = rf_proxies[proxy][[\"date\", \"rf_monthly\"]].rename(\n                columns={\"rf_monthly\": f\"rf_{proxy}\"}\n            )\n            blended = blended.merge(proxy_df, on=\"date\", how=\"left\")\n\n            # Fill missing values from this proxy\n            mask = blended[\"rf_monthly\"].isna() & blended[f\"rf_{proxy}\"].notna()\n            blended.loc[mask, \"rf_monthly\"] = blended.loc[mask, f\"rf_{proxy}\"]\n            blended.loc[mask, \"source\"] = proxy\n\n            blended = blended.drop(columns=[f\"rf_{proxy}\"])\n\n    return blended\n\nrf_blended = construct_blended_rf(rf_proxies)\n```\n:::\n\n\n::: {#tbl-blended-source .cell tbl-cap='Data Source Composition of Blended Risk-Free Rate Series' execution_count=8}\n``` {.python .cell-code}\nsource_comp = (\n    rf_blended\n    .groupby(\"source\")\n    .agg(\n        n_months=(\"date\", \"count\"),\n        pct=(\"date\", lambda x: len(x) / len(rf_blended) * 100)\n    )\n    .round(1)\n    .sort_values(\"n_months\", ascending=False)\n)\n\nsource_comp\n```\n:::\n\n\n### Properties of the Constructed Series\n\n::: {#tbl-rf-summary-stats .cell tbl-cap='Summary Statistics of Monthly Risk-Free Rate Proxies' execution_count=9}\n``` {.python .cell-code}\nrf_wide = rf_all.pivot_table(\n    index=\"date\", columns=\"proxy\", values=\"rf_monthly\"\n)\n\nsummary = rf_wide.describe(percentiles=[0.10, 0.25, 0.50, 0.75, 0.90]).T\nsummary = summary[[\"mean\", \"std\", \"min\", \"10%\", \"50%\", \"90%\", \"max\"]]\nsummary.columns = [\n    \"Mean\", \"Std\", \"Min\", \"P10\", \"Median\", \"P90\", \"Max\"\n]\n\n# Convert to annualized percentage for interpretability\n(summary * 12 * 100).round(2)\n```\n:::\n\n\n::: {#fig-rf-monthly-comparison .cell execution_count=10}\n``` {.python .cell-code}\nfig, axes = plt.subplots(2, 1, figsize=(8, 6), sharex=True)\n\n# Level\nfor proxy, color in [\n    (\"govt_bond_1y\", \"#2C73D2\"),\n    (\"interbank_overnight\", \"#FF6B6B\"),\n    (\"sbv_refinancing\", \"#5DCEAF\")\n]:\n    subset = rf_proxies[proxy].sort_values(\"date\")\n    axes[0].plot(\n        subset[\"date\"], subset[\"rf_monthly\"] * 100,\n        label=proxy.replace(\"_\", \" \").title(),\n        color=color, linewidth=1\n    )\naxes[0].set_ylabel(\"Monthly Rate (%)\")\naxes[0].legend(frameon=False, fontsize=9)\naxes[0].spines[\"top\"].set_visible(False)\naxes[0].spines[\"right\"].set_visible(False)\n\n# Pairwise spread: govt bond - interbank\nmerged = rf_proxies[\"govt_bond_1y\"][[\"date\", \"rf_monthly\"]].merge(\n    rf_proxies[\"interbank_overnight\"][[\"date\", \"rf_monthly\"]],\n    on=\"date\", suffixes=(\"_bond\", \"_interbank\")\n)\nmerged[\"spread\"] = (merged[\"rf_monthly_bond\"] - merged[\"rf_monthly_interbank\"]) * 100\n\naxes[1].fill_between(\n    merged[\"date\"], merged[\"spread\"], 0,\n    where=merged[\"spread\"] > 0, alpha=0.4, color=\"#2C73D2\", label=\"Bond > Interbank\"\n)\naxes[1].fill_between(\n    merged[\"date\"], merged[\"spread\"], 0,\n    where=merged[\"spread\"] <= 0, alpha=0.4, color=\"#FF6B6B\", label=\"Bond < Interbank\"\n)\naxes[1].axhline(0, color=\"black\", linewidth=0.5)\naxes[1].set_ylabel(\"Spread (% monthly)\")\naxes[1].set_xlabel(\"\")\naxes[1].legend(frameon=False, fontsize=9)\naxes[1].spines[\"top\"].set_visible(False)\naxes[1].spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\nThe spread between proxies is informative. A consistently positive spread (bond yield \\> interbank rate) reflects the term premium embedded in the 1-year bond. Periods where the interbank rate spikes above the bond yield typically correspond to liquidity crunches in the banking system.\n\n### Correlation Across Proxies\n\n::: {#tbl-rf-correlation .cell tbl-cap='Pairwise Correlation of Monthly Risk-Free Rate Proxies' execution_count=11}\n``` {.python .cell-code}\nrf_corr = rf_wide.corr().round(3)\nrf_corr.index = [x.replace(\"_\", \" \").title() for x in rf_corr.index]\nrf_corr.columns = [x.replace(\"_\", \" \").title() for x in rf_corr.columns]\nrf_corr\n```\n:::\n\n\nHigh correlation (\\> 0.8) between proxies suggests that the level and direction of interest rate movements are captured similarly by all proxies. Low correlation would indicate that the choice of proxy introduces substantial idiosyncratic variation into excess returns.\n\n## Excess Return Construction\n\nWith the risk-free rate series in hand, we now construct excess returns for individual stocks and for the market portfolio.\n\n### Matching Conventions\n\nExcess return construction requires strict consistency across three dimensions (@tbl-rf-consistency).\n\n| Dimension | Requirement | Common Error |\n|----------------------|------------------------|--------------------------|\n| Currency | Same currency for $r_i$ and $r_f$ | Using USD rate for VND-denominated returns |\n| Frequency | Same holding period | Using annualized $r_f$ with monthly $r_i$ |\n| Compounding | Same convention | Mixing log and arithmetic returns |\n\n: Consistency Requirements for Excess Returns {#tbl-rf-consistency}\n\n::: {#construct-excess-returns .cell execution_count=12}\n``` {.python .cell-code}\n# Load monthly stock returns\nstock_returns = pd.read_parquet(\"data/monthly_returns.parquet\")\n# Assume columns: symbol, date (month-end), ret\n\n# Merge with risk-free rate\n# Use the blended series as the baseline\nrf_for_merge = rf_blended[[\"date\", \"rf_monthly\"]].rename(\n    columns={\"rf_monthly\": \"rf\"}\n)\n\nstock_returns = stock_returns.merge(rf_for_merge, on=\"date\", how=\"left\")\n\n# Compute excess returns\nstock_returns[\"ret_excess\"] = stock_returns[\"ret\"] - stock_returns[\"rf\"]\n```\n:::\n\n\n### Market Excess Return\n\n::: {#compute-mktrf .cell execution_count=13}\n``` {.python .cell-code}\n# Value-weighted market return\nmarket_monthly = (\n    stock_returns\n    .groupby(\"date\")\n    .apply(\n        lambda g: np.average(\n            g[\"ret\"].dropna(),\n            weights=g[\"mktcap\"].loc[g[\"ret\"].dropna().index]\n        ) if g[\"ret\"].dropna().shape[0] > 0 else np.nan,\n        include_groups=False\n    )\n    .reset_index(name=\"rm\")\n)\n\nmarket_monthly = market_monthly.merge(rf_for_merge, on=\"date\", how=\"left\")\nmarket_monthly[\"mktrf\"] = market_monthly[\"rm\"] - market_monthly[\"rf\"]\n```\n:::\n\n\n::: {#fig-mktrf-timeseries .cell execution_count=14}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(8, 3.5))\n\nax.bar(\n    market_monthly[\"date\"], market_monthly[\"mktrf\"] * 100,\n    color=np.where(market_monthly[\"mktrf\"] >= 0, \"#2C73D2\", \"#FF6B6B\"),\n    width=25, alpha=0.8\n)\nax.axhline(0, color=\"black\", linewidth=0.5)\nax.set_ylabel(\"Market Excess Return (%)\")\nax.set_xlabel(\"\")\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Sensitivity Analysis: How Much Does the Proxy Choice Matter?\n\nThis is the central empirical question of the chapter. If different risk-free proxies produce essentially the same downstream results, the choice is inconsequential. If they produce different results, researchers must justify their choice and report robustness.\n\n### Effect on the Equity Premium\n\n::: {#tbl-equity-premium-sensitivity .cell tbl-cap='Annualized Equity Premium Under Alternative Risk-Free Proxies' execution_count=15}\n``` {.python .cell-code}\nresults = []\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n    merged = market_monthly[[\"date\", \"rm\"]].merge(rf_merge, on=\"date\", how=\"inner\")\n    merged[\"mktrf_proxy\"] = merged[\"rm\"] - merged[\"rf_proxy\"]\n\n    n_months = merged[\"mktrf_proxy\"].count()\n    mean_monthly = merged[\"mktrf_proxy\"].mean()\n    std_monthly = merged[\"mktrf_proxy\"].std()\n    sharpe = mean_monthly / std_monthly if std_monthly > 0 else np.nan\n    t_stat = mean_monthly / (std_monthly / np.sqrt(n_months))\n\n    results.append({\n        \"Proxy\": proxy_name.replace(\"_\", \" \").title(),\n        \"N Months\": n_months,\n        \"Mean (% ann.)\": round(mean_monthly * 12 * 100, 2),\n        \"Std (% ann.)\": round(std_monthly * np.sqrt(12) * 100, 2),\n        \"Sharpe (ann.)\": round(sharpe * np.sqrt(12), 3),\n        \"t-stat\": round(t_stat, 2)\n    })\n\npd.DataFrame(results).style.hide(axis=\"index\")\n```\n:::\n\n\n### Effect on Factor Premiums\n\n::: {#tbl-factor-premium-sensitivity .cell tbl-cap='Factor Premium Sensitivity to Risk-Free Proxy (Annualized %)' execution_count=16}\n``` {.python .cell-code}\n# Load or construct factor returns\n# Assume factors_monthly has: date, smb, hml (these are long-short, rf-independent)\n# Only MKTRF changes with the proxy\n\nfactors_monthly = pd.read_parquet(\"data/factors_monthly.parquet\")\n\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n    factors_merged = factors_monthly.merge(rf_merge, on=\"date\", how=\"inner\")\n    factors_merged = factors_merged.merge(\n        market_monthly[[\"date\", \"rm\"]], on=\"date\", how=\"inner\"\n    )\n    factors_merged[f\"mktrf_{proxy_name}\"] = (\n        factors_merged[\"rm\"] - factors_merged[\"rf_proxy\"]\n    )\n\n    mean_mktrf = factors_merged[f\"mktrf_{proxy_name}\"].mean() * 12 * 100\n    mean_smb = factors_merged[\"smb\"].mean() * 12 * 100\n    mean_hml = factors_merged[\"hml\"].mean() * 12 * 100\n\n    print(\n        f\"{proxy_name:>25s}: MKTRF = {mean_mktrf:6.2f}%, \"\n        f\"SMB = {mean_smb:6.2f}%, HML = {mean_hml:6.2f}%\"\n    )\n```\n:::\n\n\nNote that SMB and HML are constructed as long-short portfolio returns and should be identical regardless of the risk-free proxy. Only MKTRF differs. However, if the researcher uses the risk-free rate to compute individual stock excess returns before sorting into factor portfolios, small differences in sorting may arise.\n\n### Effect on Alpha Estimates\n\nThe choice of risk-free proxy affects alpha estimates for any portfolio evaluated against a factor model. We illustrate this by estimating the alpha of a momentum portfolio under each proxy.\n\n::: {#tbl-alpha-sensitivity .cell tbl-cap='Momentum Portfolio Alpha Sensitivity to Risk-Free Proxy' execution_count=17}\n``` {.python .cell-code}\nimport statsmodels.api as sm\n\n# Assume momentum_ret contains: date, mom_ret (raw return of WML portfolio)\nmomentum_ret = pd.read_parquet(\"data/momentum_returns.parquet\")\n\nalpha_results = []\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n\n    merged = (\n        momentum_ret\n        .merge(rf_merge, on=\"date\", how=\"inner\")\n        .merge(market_monthly[[\"date\", \"rm\"]], on=\"date\", how=\"inner\")\n        .merge(factors_monthly[[\"date\", \"smb\", \"hml\"]], on=\"date\", how=\"inner\")\n    )\n\n    merged[\"mom_excess\"] = merged[\"mom_ret\"] - merged[\"rf_proxy\"]\n    merged[\"mktrf\"] = merged[\"rm\"] - merged[\"rf_proxy\"]\n\n    X = sm.add_constant(merged[[\"mktrf\", \"smb\", \"hml\"]])\n    y = merged[\"mom_excess\"]\n    model = sm.OLS(y, X).fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 6})\n\n    alpha_results.append({\n        \"Proxy\": proxy_name.replace(\"_\", \" \").title(),\n        \"Alpha (% monthly)\": round(model.params[\"const\"] * 100, 3),\n        \"t-stat\": round(model.tvalues[\"const\"], 2),\n        \"R²\": round(model.rsquared, 3)\n    })\n\npd.DataFrame(alpha_results).style.hide(axis=\"index\")\n```\n:::\n\n\n### Effect on Valuation\n\nTo illustrate the valuation impact, consider a simple DCF exercise where the cost of equity is estimated via the CAPM.\n\n::: {#tbl-valuation-sensitivity .cell tbl-cap='Cost of Equity and Terminal Value Sensitivity to Risk-Free Proxy' execution_count=18}\n``` {.python .cell-code}\n# Example: firm with beta = 1.0, expected CF = 1 billion VND, growth = 3%\nbeta_example = 1.0\ncf = 1e9  # VND\ngrowth = 0.03\n\nvaluation_results = []\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_ann = proxy_df[\"rf_annual\"].dropna().iloc[-12:].mean() / 100  # Latest year avg\n\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n    mkt_merged = market_monthly[[\"date\", \"rm\"]].merge(\n        rf_merge, on=\"date\", how=\"inner\"\n    )\n    mkt_merged[\"mktrf\"] = mkt_merged[\"rm\"] - mkt_merged[\"rf_proxy\"]\n    erp = mkt_merged[\"mktrf\"].mean() * 12  # Annualized equity premium\n\n    cost_equity = rf_ann + beta_example * erp\n    terminal_value = cf / (cost_equity - growth) if cost_equity > growth else np.nan\n\n    valuation_results.append({\n        \"Proxy\": proxy_name.replace(\"_\", \" \").title(),\n        \"Rf (% ann.)\": round(rf_ann * 100, 2),\n        \"ERP (% ann.)\": round(erp * 100, 2),\n        \"Cost of Equity (%)\": round(cost_equity * 100, 2),\n        \"Terminal Value (B VND)\": round(terminal_value / 1e9, 1) if terminal_value else \"N/A\"\n    })\n\npd.DataFrame(valuation_results).style.hide(axis=\"index\")\n```\n:::\n\n\n::: callout-important\n## Key Finding\n\nEven modest differences in the risk-free rate (50-150 basis points across proxies) can produce terminal value differences of 10-30%. Researchers and practitioners must document their risk-free rate choice explicitly and report sensitivity to alternatives.\n:::\n\n## Term Structure Considerations\n\nWhen longer-horizon discount rates are needed (e.g., for multi-year DCF or cost of capital estimation), the risk-free rate should be maturity-matched. This requires constructing a yield curve from available government bond data.\n\n### Yield Curve Estimation\n\n@gurkaynak2007us develop a parametric approach to yield curve estimation using the @nelson1987parsimonious and @svensson1994estimating models. The Nelson-Siegel model parameterizes the instantaneous forward rate as:\n\n$$\nf(\\tau) = \\beta_0 + \\beta_1 \\exp\\left(-\\frac{\\tau}{\\lambda}\\right) + \\beta_2 \\frac{\\tau}{\\lambda} \\exp\\left(-\\frac{\\tau}{\\lambda}\\right)\n$$ {#eq-nelson-siegel}\n\nwhere $\\tau$ is the maturity, $\\beta_0$ is the long-run level, $\\beta_1$ determines the slope, $\\beta_2$ determines the curvature, and $\\lambda$ controls the location of the hump.\n\nThe corresponding yield is:\n\n$$\ny(\\tau) = \\beta_0 + \\beta_1 \\frac{1 - \\exp(-\\tau/\\lambda)}{\\tau/\\lambda} + \\beta_2 \\left[\\frac{1 - \\exp(-\\tau/\\lambda)}{\\tau/\\lambda} - \\exp(-\\tau/\\lambda)\\right]\n$$ {#eq-ns-yield}\n\n::: {#nelson-siegel-estimation .cell execution_count=19}\n``` {.python .cell-code}\nfrom scipy.optimize import minimize\n\ndef nelson_siegel_yield(tau, beta0, beta1, beta2, lam):\n    \"\"\"Nelson-Siegel yield curve model.\"\"\"\n    tau_lam = tau / lam\n    factor1 = (1 - np.exp(-tau_lam)) / tau_lam\n    factor2 = factor1 - np.exp(-tau_lam)\n    return beta0 + beta1 * factor1 + beta2 * factor2\n\ndef fit_nelson_siegel(maturities, yields):\n    \"\"\"Fit Nelson-Siegel model to observed yields.\"\"\"\n    def objective(params):\n        beta0, beta1, beta2, lam = params\n        if lam <= 0:\n            return 1e10\n        fitted = nelson_siegel_yield(maturities, beta0, beta1, beta2, lam)\n        return np.sum((yields - fitted) ** 2)\n\n    result = minimize(\n        objective,\n        x0=[yields[-1], yields[0] - yields[-1], 0, 2.0],\n        method=\"Nelder-Mead\",\n        options={\"maxiter\": 10000}\n    )\n    return result.x\n\n# Example: fit to latest available government bond yields\n# Assume govt_yields contains: date, maturity_years, yield_pct\ngovt_yields = pd.read_parquet(\"data/govt_bond_yields.parquet\")\n\nlatest_date = govt_yields[\"date\"].max()\nlatest_yields = govt_yields[govt_yields[\"date\"] == latest_date].sort_values(\"maturity_years\")\n\nmaturities = latest_yields[\"maturity_years\"].values\nyields = latest_yields[\"yield_pct\"].values\n\nparams = fit_nelson_siegel(maturities, yields)\nbeta0, beta1, beta2, lam = params\n```\n:::\n\n\n::: {#fig-yield-curve .cell execution_count=20}\n``` {.python .cell-code}\ntau_fine = np.linspace(0.25, 30, 200)\nfitted_yields = nelson_siegel_yield(tau_fine, *params)\n\nfig, ax = plt.subplots(figsize=(7, 4))\nax.scatter(\n    maturities, yields, color=\"#FF6B6B\", s=60, zorder=5,\n    label=\"Observed yields\", edgecolors=\"white\"\n)\nax.plot(\n    tau_fine, fitted_yields, color=\"#2C73D2\", linewidth=2,\n    label=\"Nelson-Siegel fit\"\n)\nax.set_xlabel(\"Maturity (Years)\")\nax.set_ylabel(\"Yield (%)\")\nax.legend(frameon=False)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Nelson-Siegel parameters:\")\nprint(f\"  β₀ (level)     = {beta0:.4f}\")\nprint(f\"  β₁ (slope)     = {beta1:.4f}\")\nprint(f\"  β₂ (curvature) = {beta2:.4f}\")\nprint(f\"  λ (decay)      = {lam:.4f}\")\n```\n:::\n\n\n::: callout-tip\nThe Nelson-Siegel yield curve allows extraction of a risk-free rate at any maturity. For monthly asset pricing, evaluate the curve at $\\tau = 1/12$ (one month). For DCF valuation with a 10-year horizon, evaluate at $\\tau = 10$. This maturity-matching approach is superior to using a single proxy for all purposes.\n:::\n\n### Extracting the Short-Rate from the Yield Curve\n\n::: {#extract-short-rate .cell execution_count=21}\n``` {.python .cell-code}\n# Extract 1-month rate from Nelson-Siegel curve at each date\ndef extract_ns_short_rate(govt_yields, target_maturity=1/12):\n    \"\"\"\n    For each date, fit Nelson-Siegel and extract the yield\n    at the target maturity.\n    \"\"\"\n    dates = govt_yields[\"date\"].unique()\n    short_rates = []\n\n    for d in dates:\n        obs = govt_yields[govt_yields[\"date\"] == d].sort_values(\"maturity_years\")\n        if len(obs) < 3:  # Need at least 3 points to fit\n            short_rates.append({\"date\": d, \"rf_ns\": np.nan})\n            continue\n\n        try:\n            params = fit_nelson_siegel(\n                obs[\"maturity_years\"].values,\n                obs[\"yield_pct\"].values\n            )\n            rf_ns = nelson_siegel_yield(target_maturity, *params)\n            short_rates.append({\"date\": d, \"rf_ns\": rf_ns})\n        except Exception:\n            short_rates.append({\"date\": d, \"rf_ns\": np.nan})\n\n    return pd.DataFrame(short_rates)\n\nns_short_rates = extract_ns_short_rate(govt_yields)\n```\n:::\n\n\n## Real vs. Nominal Risk-Free Rates\n\nFor certain applications, particularly long-horizon valuation and real return analysis, the real (inflation-adjusted) risk-free rate is more appropriate than the nominal rate. The Fisher equation relates them:\n\n$$\nr_f^{real} \\approx r_f^{nominal} - \\pi^{e}\n$$ {#eq-fisher}\n\nwhere $\\pi^e$ is expected inflation. In practice, we can use realized CPI inflation as a proxy for expected inflation (under the assumption of rational expectations, or as an ex-post adjustment).\n\n::: {#compute-real-rf .cell execution_count=22}\n``` {.python .cell-code}\n# Load CPI data\n# Assume cpi_data contains: date, cpi_index (or inflation_mom for month-over-month)\ncpi_data = pd.read_parquet(\"data/cpi_monthly.parquet\")\ncpi_data = cpi_data.sort_values(\"date\")\ncpi_data[\"inflation_monthly\"] = cpi_data[\"cpi_index\"].pct_change()\n\nrf_real = rf_blended[[\"date\", \"rf_monthly\"]].merge(\n    cpi_data[[\"date\", \"inflation_monthly\"]], on=\"date\", how=\"inner\"\n)\nrf_real[\"rf_real\"] = rf_real[\"rf_monthly\"] - rf_real[\"inflation_monthly\"]\n```\n:::\n\n\n::: {#fig-real-vs-nominal .cell execution_count=23}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(8, 4))\nax.plot(\n    rf_real[\"date\"], rf_real[\"rf_monthly\"] * 100,\n    color=\"#2C73D2\", label=\"Nominal\", linewidth=1\n)\nax.plot(\n    rf_real[\"date\"], rf_real[\"rf_real\"] * 100,\n    color=\"#FF6B6B\", label=\"Real\", linewidth=1\n)\nax.axhline(0, color=\"black\", linewidth=0.5, linestyle=\"--\")\nax.set_ylabel(\"Monthly Rate (%)\")\nax.set_xlabel(\"\")\nax.legend(frameon=False)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n::: callout-note\nIn periods of high inflation, the real risk-free rate can be substantially negative. This has implications for real excess return computation and for interpreting the equity premium in real terms. A negative real risk-free rate implies that nominal government securities do not preserve purchasing power, which strengthens the case for equity investment from a real-return perspective.\n:::\n\n## International Comparison\n\nIt is instructive to compare Vietnam's risk-free rate environment with that of other emerging and developed markets to contextualize the magnitudes involved.\n\n\nVietnam's risk-free rate environment is characterized by relatively high nominal rates (reflecting inflation and growth dynamics), limited availability of very-short-maturity sovereign instruments, and greater reliance on interbank rates as the operational proxy. This is broadly similar to other ASEAN frontier markets but contrasts sharply with developed Asian markets, where deep government securities markets provide clean short-term benchmarks.\n\n## Best Practices Checklist\n\nBased on the analysis in this chapter, we summarize the recommended practices for risk-free rate construction in Vietnamese financial research:\n\n\n## Saving the Risk-Free Rate for Downstream Use\n\nThe final step is to save the constructed risk-free rate series for use in subsequent chapters.\n\n::: {#save-rf-series .cell execution_count=26}\n``` {.python .cell-code}\n# Save all variants for flexibility\nrf_output = rf_blended[[\"date\", \"rf_monthly\", \"source\"]].copy()\nrf_output[\"rf_annual_pct\"] = rf_output[\"rf_monthly\"] * 12 * 100\n\n# Also save individual proxies\nfor proxy_name, proxy_df in rf_proxies.items():\n    col_name = f\"rf_{proxy_name}\"\n    rf_output = rf_output.merge(\n        proxy_df[[\"date\", \"rf_monthly\"]].rename(\n            columns={\"rf_monthly\": col_name}\n        ),\n        on=\"date\",\n        how=\"left\"\n    )\n\n# Save to parquet for use in later chapters\nrf_output.to_parquet(\"data/risk_free_rate.parquet\", index=False)\n\nprint(f\"Risk-free rate series saved: {len(rf_output)} months\")\nprint(f\"Date range: {rf_output['date'].min()} to {rf_output['date'].max()}\")\nprint(f\"\\nColumns: {list(rf_output.columns)}\")\n```\n:::\n\n\n::: callout-tip\nBy saving the risk-free rate as a separate, well-documented file, all downstream chapters can merge it consistently. This avoids the common pitfall of reconstructing the risk-free rate differently in different analyses within the same study.\n:::\n\n## Summary\n\nThis chapter has established that risk-free rate construction is a first-order modeling decision in Vietnamese financial research, not a technical afterthought. The key takeaways are:\n\n1.  **No perfect proxy exists** in Vietnam. The interbank overnight rate, 1-year government bond yield, and SBV policy rate each have distinct strengths and limitations. A blended series using a documented priority hierarchy provides the most robust baseline.\n\n2.  **The choice of proxy matters quantitatively**. Different proxies can shift the estimated equity premium by 50-200 basis points annually, alter portfolio alphas, and change DCF terminal values by 10-30%.\n\n3.  **Frequency alignment and compounding conventions** must be handled with care. Converting annualized rates to monthly requires specifying the compounding convention. Gaps in the data require documented interpolation.\n\n4.  **The Nelson-Siegel yield curve model** enables the extraction of any-maturity risk-free rate from sparse government bond data, which is particularly valuable for maturity-matched discount rate estimation.\n\n5.  **Sensitivity analysis is mandatory**. Any study that reports results under a single risk-free proxy without reporting robustness to alternatives has an unquantified source of specification uncertainty.\n\n<!-- ## Exercises\n\n1.  **Proxy substitution test**: Re-estimate the Fama-French three-factor model for the Vietnamese market using each of the three risk-free proxies. Report the market premium, SMB, and HML under each specification. Are the cross-sectional patterns in factor loadings sensitive to the proxy choice?\n\n2.  **Breakpoint analysis**: Identify structural breaks in the interbank overnight rate series using the @bai2003critical sequential break detection procedure. Do these breaks correspond to known monetary policy regime changes (e.g., SBV rate adjustments, regulatory changes)?\n\n3.  **Inflation-adjusted equity premium**: Compute the real equity premium by subtracting realized CPI inflation from both the market return and the nominal risk-free rate. Compare the Sharpe ratio of the market portfolio in nominal vs. real terms.\n\n4.  **Yield curve dynamics**: Estimate the Nelson-Siegel model at monthly frequency and track the time series of $\\beta_0$ (level), $\\beta_1$ (slope), and $\\beta_2$ (curvature). Do these factors predict future stock market returns or macroeconomic variables, following @Ang2006 @ang2006does?\n\n5.  **Currency-adjusted risk-free rate**: For foreign investors, the relevant risk-free rate includes currency hedging costs. Construct a USD-hedged risk-free rate using the VND/USD forward premium (covered interest parity) and compare it to the local-currency risk-free rate. How does this affect the equity premium from a foreign investor's perspective?\n\n6.  **Deposit rate ceiling effects**: During periods when the SBV imposes binding deposit rate ceilings, the observed deposit rate may be below the market-clearing rate. Identify such periods and test whether the deposit-rate-based risk-free proxy produces systematically different excess returns compared to the interbank rate during ceiling-binding vs. non-binding periods. -->\n\n",
    "supporting": [
      "04_risk_free_rate_construction_files/figure-pdf"
    ],
    "filters": []
  }
}